{"mappings":"AAAA;AAEA,MAAM,SAAS,OAAO,OAAO;IAC3B;QAAE,OAAO;QAAK,aAAa;QAAkB,MAAM;IAAQ;IAC3D;QAAE,OAAO;QAAK,aAAa;QAAgB,MAAM;IAAQ;IACzD;QAAE,OAAO;QAAM,aAAa;QAAwB,MAAM;IAAQ;IAClE;QAAE,OAAO;QAAK,aAAa;QAAqB,MAAM;IAAQ;IAC9D;QAAE,OAAO;QAAO,aAAa;QAAiB,MAAM;IAAQ;IAC5D;QAAE,OAAO;QAAK,aAAa;QAAY,MAAM;IAAU;IACvD;QAAE,OAAO;QAAM,aAAa;QAAW,MAAM;IAAU;IACvD;QAAE,OAAO;QAAO,aAAa;QAAiB,MAAM;IAAQ;CAC7D;AAED,qDAAqD;AACrD,MAAM,iBAAiB,OAAO,OAAO;IACnC,OAAO;IACP,SAAS;AACX;AACA,2EAA2E;AAC3E,4BAA4B;AAC5B,+BAA+B;AAE/B,MAAM,WAAW,CAAC,QAAQ,OAAS,QAAQ,CAAC,KAAK,IAAI;AAErD,oCAAoC;AACpC,MAAM,aAAa,SACjB,KAAK,EACL,MAAM,EACN,KAAK,EACL,WAAW,EACX,OAAO,OAAO;IAEd,yFAAyF;IACzF,MAAM,YAAY,KAAK;IACvB,iEAAiE;IACjE,mEAAmE;IACnE,6CAA6C;IAC7C,gCAAgC;IAEhC,OAAO,SAAS,SAAS,QAAQ,aAE7B;WAAI;QAAO;YAAE,OAAO,CAAC;YAAO;YAAa,MAAM;QAAU;KAAE,GAC3D;AACJ,gEAAgE;AAClE;AACA,gKAAgK;AAChK,MAAM,aAAa,WAAW,QAAQ,gBAAgB,GAAG;AACzD,QAAQ,IAAI;AACZ,sGAAsG;AACtG,MAAM,aAAa,WAAW,YAAY,gBAAgB,IAAI;AAC9D,QAAQ,IAAI;AACZ,MAAM,aAAa,WACjB,YACA,gBACA,KACA,gCACA;AAEF,QAAQ,IAAI;AACZ,WAAW,QAAQ,gBAAgB,KAAK,SAAS;AAEjD,mDAAmD;AACnD,yEAAyE;AACzE,gCAAgC;AAChC,yDAAyD;AACzD,sCAAsC;AACtC,iBAAiB;AACjB,QAAQ;AACR,mCAAmC;AACnC,gFAAgF;AAChF,KAAK;AAEL,6JAA6J;AAC7J,MAAM,gBAAgB,CAAC,OAAO,SAC5B,MAAM,IAAI,CAAA,QACR,MAAM,QAAQ,CAAC,SAAS,QAAQ,MAAM,QAClC;YAAE,GAAG,KAAK;YAAE,MAAM;QAAQ,IAC1B;AAGR,MAAM,cAAc,cAAc,YAAY;AAC9C,QAAQ,IAAI;AAEZ,MAAM,iBAAiB,SAAU,KAAK,EAAE,QAAQ;IAC9C,mBAAmB;IACnB,8BAA8B;IAC9B,cAAc;IACd,2EAA2E;IAC3E,oDAAoD;IACpD,uBAAuB;IACvB,MAAM,iBAAiB,MACpB,OAAO,CAAA,QAAS,MAAM,SAAS,CAAC,UAChC,IAAI,CAAA,QAAS,MAAM,YAAY,MAAM,KACrC,KAAK;IACR,+BAA+B;IAC/B,sEAAsE;IACtE,QAAQ,IAAI,iBAAiB,uIAAuI;AACtK;AAEA,sBAAsB;AACtB,eAAe,aAAa","sources":["clean.js"],"sourcesContent":["'strict mode';\r\n\r\nconst budget = Object.freeze([\r\n  { value: 250, description: 'Sold old TV ðŸ“º', user: 'jonas' },\r\n  { value: -45, description: 'Groceries ðŸ¥‘', user: 'jonas' },\r\n  { value: 3500, description: 'Monthly salary ðŸ‘©â€ðŸ’»', user: 'jonas' },\r\n  { value: 300, description: 'Freelancing ðŸ‘©â€ðŸ’»', user: 'jonas' },\r\n  { value: -1100, description: 'New iPhone ðŸ“±', user: 'jonas' },\r\n  { value: -20, description: 'Candy ðŸ­', user: 'matilda' },\r\n  { value: -125, description: 'Toys ðŸš‚', user: 'matilda' },\r\n  { value: -1800, description: 'New Laptop ðŸ’»', user: 'jonas' },\r\n]);\r\n\r\n//Making an array or object immutable by using freeze\r\nconst spendingLimits = Object.freeze({\r\n  jonas: 1500,\r\n  matilda: 100,\r\n});\r\n//Lets see what happens when we try to add a new property to spendingLimits\r\n// spendingLimits.jay = 200;\r\n// console.log(spendingLimits);\r\n\r\nconst getLimit = (limits, user) => limits?.[user] ?? 0;\r\n\r\n//Pure function without side effects\r\nconst addExpense = function (\r\n  state,\r\n  limits,\r\n  value,\r\n  description,\r\n  user = 'jonas'\r\n) {\r\n  //new variable for lower case to make a copy of the user and \"cleaning it how we want it\"\r\n  const cleanUser = user.toLowerCase();\r\n  // const limit = spendingLimits[user] ? spendingLimits[user] : 0;\r\n  //or by using optional chaining and the nullish coalescing operator\r\n  // const limit = spendingLimits?.[user] ?? 0;\r\n  // const limit = getLimit(user);\r\n\r\n  return value <= getLimit(limits, cleanUser)\r\n    ? //Create a new (copy of the object) to manipulate with the spread operator and copy everything in the original array but add one item to it\r\n      [...state, { value: -value, description, user: cleanUser }]\r\n    : state;\r\n  // budget.push({ value: -value, description, user: cleanUser });\r\n};\r\n//Now addexpense will not mutate the original data anymore but if we want to do something with the data we need to store it somewhere, for example in a variable\r\nconst newBudget1 = addExpense(budget, spendingLimits, 5, 'Ice cream');\r\nconsole.log(newBudget1);\r\n//if we want to add the previous change along with the next one we need to add it in the function call\r\nconst newBudget2 = addExpense(newBudget1, spendingLimits, 10, 'Pizza ðŸ•');\r\nconsole.log(newBudget2);\r\nconst newBudget3 = addExpense(\r\n  newBudget2,\r\n  spendingLimits,\r\n  100,\r\n  'Going to movies ðŸ¿',\r\n  'Matilda'\r\n);\r\nconsole.log(newBudget3);\r\naddExpense(budget, spendingLimits, 200, 'Stuff', 'Jay');\r\n\r\n// const checkExpenses = function (state, limits) {\r\n//   //Make original data immutable using map to create a brand new array\r\n//   return state.map(entry => {\r\n//     return entry.value < -getLimit(limits, entry.user)\r\n//       ? { ...entry, flag: 'limit' }\r\n//       : entry;\r\n//   });\r\n//   // for (const entry of budget)\r\n//   //   if (entry.value < -getLimit(limits, entry.user)) entry.flag = 'limit';\r\n// };\r\n\r\n//To make the above function into an arrow function (a pure function that doesn't affect anything outside it's scope) because we create a new array with .map\r\nconst checkExpenses = (state, limits) =>\r\n  state.map(entry =>\r\n    entry.value < -getLimit(limits, entry.user)\r\n      ? { ...entry, flag: 'limit' }\r\n      : entry\r\n  );\r\n\r\nconst finalBudget = checkExpenses(newBudget3, spendingLimits);\r\nconsole.log(finalBudget);\r\n\r\nconst logBigExpenses = function (state, bigLimit) {\r\n  // let output = '';\r\n  // for (const entry of budget)\r\n  //   output +=\r\n  //     entry.value <= -bigLimit ? `${entry.description.slice(-2)} / ` : '';\r\n  // output = output.slice(0, -2); // Remove last '/ '\r\n  // console.log(output);\r\n  const logBigExpenses = state\r\n    .filter(entry => entry.value <= -bigLimit)\r\n    .map(entry => entry.description.slice(-2))\r\n    .join(' / ');\r\n  //Another way of doing this is:\r\n  // .reduce((str, cur) => `${str} / ${cur.description.slice(-2)}`, '');\r\n  console.log(logBigExpenses); // A console.log like this is also a side effect, but you will always need some side effects how else would we know our code is running\r\n};\r\n\r\n//console.log(budget);\r\nlogBigExpenses(finalBudget, 500);\r\n"],"names":[],"version":3,"file":"index.3ec6c1be.js.map","sourceRoot":"/__parcel_source_root/"}